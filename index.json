{
  "release-notes.html": {
    "href": "release-notes.html",
    "title": "Cursively Release Notes | Cursively",
    "keywords": "Cursively Release Notes 1.2.0 Added fluent helpers to replace the Csv.ProcessFoo methods with something that's easier to maintain without being meaningfully less convenient to use ( #15 ). Deprecated the ability to ignore a leading UTF-8 byte order mark inside the header-aware visitor, per #14 . Instead, it's up to the source of the input to skip (or not skip) sending a leading UTF-8 BOM to the tokenizer in the first place. By default, all the fluent helpers from the previous bullet point will ignore a leading UTF-8 BOM if present. This behavior may be disabled by chaining .WithIgnoreUTF8ByteOrderMark(false) . Improved how the header-aware visitor behaves when the creator requests very high limits ( #17 ). Fixed a rare off-by-one issue in the header-aware visitor that would happen when a header is exactly as long as the configured maximum and its last byte is exactly the last byte of the input chunk that happens to contain it ( #16 ). 1.1.0 Several further performance optimizations. Most significantly, inlining and tuning a critical ReadOnlySpan<T> extension method. In some cases, this increased throughput by a factor of 3. Added hooks for visitor implementations to detect situations where the stream does not conform to the RFC 4180 rules for quoted fields ( #4 ) Added support to customize the field delimiter byte ( #11 ) Added helpers to avoid having to use CsvTokenizer directly in most cases ( #9 , #10 ) Added an intermediate abstract visitor class that handles UTF-8 encoded headers ( #5 ) 1.0.0 Initial release."
  },
  "index.html": {
    "href": "index.html",
    "title": "Cursively | Cursively",
    "keywords": "Cursively A fast, RFC 4180 -conforming CSV reading library for .NET. Written in C#. Fully supports all UTF-8 encoded byte streams. Other encodings will work as well, as long as the bytes 0x0A , 0x0D , 0x22 , and 0x2C are all guaranteed to mean the same thing that they mean in ASCII / UTF-8, and as long as the encoding defines no other byte sequences which identify the Unicode code points for '\\n' , '\\r' , '\"' , or ',' , respectively. In practice, this means that most \"Extended ASCII\" code pages will probably work, probably including all SBCS. Many \"Extended ASCII\" DBCS will probably work too, but it looks like Shift-JIS will not work. Notably, this library will fail to yield the correct result when used with byte streams encoded in any variant of UTF-16 or UTF-32, even with a BOM header. If you require that support, there are other libraries that should work for you. Fully supports all streams that completely conform to the RFC 4180 format, and defines rules for how to handle streams that break certain rules of RFC 4180 in a way that seems to be consistent with other popular tools, at a minor speed penalty. This library exists because the original developer was unsatisfied with the performance characteristics of raw CSV processing tools. Everything out there seemed to have some combination of these flaws: Tons of managed heap allocations on hot paths, often baked into the API requirements Decoding to UTF-16LE before scanning for critical bytes, which could be considered a subset of: The design forces a ton of processing to happen on the input which the caller might not even care about Omitting important parts of RFC 4180 Disappointing options for mitigating DDoS risk \"RFC 4180 over UTF-8\" is a very simple byte stream format, and the state machine requires only a few extra states to define how to handle all UTF-8 streams that are non-RFC 4180, so it seemed odd that there wasn't a reader without these flaws. With Cursively, each stream only strictly requires a grand total of two objects to be allocated on the managed heap*, *in case this is too much, both could be reset and put into a pool to be reused for processing other streams processing happens directly on the input bytes (no decoding is done by Cursively itself), the only processing that Cursively necessarily does is the bare minimum needed to describe the data to the caller, inputs that conform to RFC 4180* are processed according to all the rules of RFC 4180, and *inputs that do not conform to RFC 4180 are handled according to consistent, intuitive rules there is a very low risk* of DDoS directly from using Cursively, and the caller has the tools that they need in order to prevent (or respond to) attacks in a more \"natural\" way than other CSV libraries that the developer has seen. *There is no such thing as \"risk-free\" in our world. Cursively itself cannot eliminate the risk of attacks that use it as a vector to exploit defects in CoreFX / C# compiler / runtime / OS / hardware. Future enhancements may add support for byte streams in other encodings if there's demand for it, but not at the expense of anything that matters to the \"RFC 4180 over UTF-8\" use case."
  },
  "benchmark-1.2.0.html": {
    "href": "benchmark-1.2.0.html",
    "title": "| Cursively",
    "keywords": "This benchmark tests the simple act of counting how many records are in a CSV file. It's not a simple count of how many lines are in the text file: line breaks within quoted fields must be treated as data, and multiple line breaks in a row must be treated as one, since each record must have at least one field. Therefore, assuming correct implementations, this benchmark should test the raw CSV processing speed. Cursively eliminates a ton of overhead found in libraries such as CsvHelper by restricting the allowed input encodings and using the visitor pattern as its only means of output. Cursively can scan through the original bytes of the input to do its work, and it can give slices of the input data directly to the consumer without having to copy or allocate. Therefore, these benchmarks are somewhat biased in favor of Cursively, as CsvHelper relies on external code to transform the data to UTF-16. This isn't as unfair as that makes it sound: the overwhelming majority of input files are probably UTF-8 anyway (or a compatible SBCS), so this transformation is something that practically every user will experience. Input files can be found here: https://github.com/airbreather/Cursively/tree/v1.2.0/test/Cursively.Benchmark/large-csv-files.zip Benchmark source code is this: https://github.com/airbreather/Cursively/tree/v1.2.0/test/Cursively.Benchmark As of version 1.2.0, these benchmarks no longer run on .NET Framework targets, because earlier benchmarks have shown comparable ratios. Raw BenchmarkDotNet output is at the bottom, but here are some numbers derived from it showing the throughput of CsvHelper compared to the throughput of each of five different ways of using Cursively on multiple different kinds of files. This summary does not indicate anything about the GC pressure: File Size (bytes) CsvHelper (MB/s) Cursively 1* (MB/s) Cursively 2* (MB/s) Cursively 3* (MB/s) Cursively 4* (MB/s) Cursively 5* (MB/s) 100-huge-records 2900444 27.68 482.15 (x17.42) 528.08 (x19.08) 443.99 (x16.04) 448.17 (x16.19) 408.70 (x14.77) 100-huge-records-quoted 4900444 29.40 304.64 (x10.36) 325.31 (x11.07) 295.21 (x10.04) 293.08 (x09.97) 285.03 (x09.70) 10k-empty-records 10020000 14.59 311.97 (x21.38) 311.27 (x21.33) 283.40 (x19.42) 297.41 (x20.38) 268.23 (x18.38) mocked 12731500 74.29 3871.72 (x52.11) 3771.89 (x50.77) 1748.01 (x23.53) 2103.55 (x28.31) 1240.09 (x16.69) worldcitiespop 151492068 39.39 622.85 (x15.81) 617.22 (x15.67) 518.00 (x13.15) 538.54 (x13.67) 450.63 (x11.44) *Different Cursively methods are: Directly using CsvTokenizer CsvSyncInput.ForMemory CsvSyncInput.ForMemoryMappedFile CsvSyncInput.ForStream (using a FileStream ) CsvAsyncInput.ForStream (using a FileStream opened in asynchronous mode) Raw BenchmarkDotNet output: BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 Intel Core i7-6850K CPU 3.60GHz (Skylake), 1 CPU, 12 logical and 6 physical cores .NET Core SDK=3.0.100-preview6-012264 [Host] : .NET Core 2.2.6 (CoreCLR 4.6.27817.03, CoreFX 4.6.27818.02), 64bit RyuJIT Job-UPPUKA : .NET Core 2.2.6 (CoreCLR 4.6.27817.03, CoreFX 4.6.27818.02), 64bit RyuJIT Server=True Method csvFile Mean Error StdDev Ratio RatioSD Gen 0 Gen 1 Gen 2 Allocated CountRowsUsingCursivelyRaw 100-huge-records 5.737 ms 0.0037 ms 0.0033 ms 1.00 0.00 - - - 48 B CountRowsUsingCursivelyArrayInput 100-huge-records 5.238 ms 0.0066 ms 0.0062 ms 0.91 0.00 - - - 96 B CountRowsUsingCursivelyMemoryMappedFileInput 100-huge-records 6.230 ms 0.0159 ms 0.0141 ms 1.09 0.00 - - - 544 B CountRowsUsingCursivelyFileStreamInput 100-huge-records 6.172 ms 0.0080 ms 0.0067 ms 1.08 0.00 - - - 272 B CountRowsUsingCursivelyAsyncFileStreamInput 100-huge-records 6.768 ms 0.1349 ms 0.1262 ms 1.18 0.02 - - - 1360 B CountRowsUsingCsvHelper 100-huge-records 99.938 ms 0.3319 ms 0.3105 ms 17.42 0.06 400.0000 200.0000 - 110256320 B CountRowsUsingCursivelyRaw 100-h(...)uoted [23] 15.341 ms 0.0305 ms 0.0255 ms 1.00 0.00 - - - 48 B CountRowsUsingCursivelyArrayInput 100-h(...)uoted [23] 14.366 ms 0.0167 ms 0.0156 ms 0.94 0.00 - - - 96 B CountRowsUsingCursivelyMemoryMappedFileInput 100-h(...)uoted [23] 15.831 ms 0.0487 ms 0.0455 ms 1.03 0.00 - - - 544 B CountRowsUsingCursivelyFileStreamInput 100-h(...)uoted [23] 15.946 ms 0.0383 ms 0.0358 ms 1.04 0.00 - - - 272 B CountRowsUsingCursivelyAsyncFileStreamInput 100-h(...)uoted [23] 16.396 ms 0.2821 ms 0.2771 ms 1.07 0.02 - - - 1360 B CountRowsUsingCsvHelper 100-h(...)uoted [23] 158.968 ms 0.1382 ms 0.1154 ms 10.36 0.02 333.3333 - - 153579848 B CountRowsUsingCursivelyRaw 10k-empty-records 30.631 ms 0.1009 ms 0.0894 ms 1.00 0.00 - - - 48 B CountRowsUsingCursivelyArrayInput 10k-empty-records 30.699 ms 0.0624 ms 0.0584 ms 1.00 0.00 - - - 96 B CountRowsUsingCursivelyMemoryMappedFileInput 10k-empty-records 33.718 ms 0.0873 ms 0.0817 ms 1.10 0.00 - - - 544 B CountRowsUsingCursivelyFileStreamInput 10k-empty-records 32.130 ms 0.0944 ms 0.0737 ms 1.05 0.00 - - - 272 B CountRowsUsingCursivelyAsyncFileStreamInput 10k-empty-records 35.625 ms 0.7018 ms 0.7801 ms 1.17 0.03 - - - 1360 B CountRowsUsingCsvHelper 10k-empty-records 654.743 ms 13.0238 ms 16.9346 ms 21.42 0.51 2000.0000 - - 420832856 B CountRowsUsingCursivelyRaw mocked 3.136 ms 0.0038 ms 0.0034 ms 1.00 0.00 - - - 48 B CountRowsUsingCursivelyArrayInput mocked 3.219 ms 0.0623 ms 0.0741 ms 1.02 0.02 - - - 96 B CountRowsUsingCursivelyMemoryMappedFileInput mocked 6.946 ms 0.0553 ms 0.0490 ms 2.21 0.02 - - - 544 B CountRowsUsingCursivelyFileStreamInput mocked 5.772 ms 0.0365 ms 0.0324 ms 1.84 0.01 - - - 272 B CountRowsUsingCursivelyAsyncFileStreamInput mocked 9.791 ms 0.1129 ms 0.1056 ms 3.12 0.04 - - - 1360 B CountRowsUsingCsvHelper mocked 163.426 ms 3.2351 ms 3.1773 ms 52.08 0.97 333.3333 - - 115757736 B CountRowsUsingCursivelyRaw worldcitiespop 231.955 ms 1.0755 ms 0.9534 ms 1.00 0.00 - - - 48 B CountRowsUsingCursivelyArrayInput worldcitiespop 234.071 ms 1.0749 ms 0.9529 ms 1.01 0.01 - - - 96 B CountRowsUsingCursivelyMemoryMappedFileInput worldcitiespop 278.909 ms 3.0866 ms 2.8872 ms 1.20 0.01 - - - 544 B CountRowsUsingCursivelyFileStreamInput worldcitiespop 268.271 ms 3.4632 ms 2.8920 ms 1.16 0.02 - - - 272 B CountRowsUsingCursivelyAsyncFileStreamInput worldcitiespop 320.606 ms 1.6204 ms 1.5157 ms 1.38 0.01 - - - 1360 B CountRowsUsingCsvHelper worldcitiespop 3,667.940 ms 60.8394 ms 56.9092 ms 15.82 0.24 15000.0000 - - 3096694312 B"
  },
  "benchmark-1.1.0.html": {
    "href": "benchmark-1.1.0.html",
    "title": "| Cursively",
    "keywords": "This benchmark tests the simple act of counting how many records are in a CSV file. It's not a simple count of how many lines are in the text file: line breaks within quoted fields must be treated as data, and multiple line breaks in a row must be treated as one, since each record must have at least one field. Therefore, assuming correct implementations, this benchmark should test the raw CSV processing speed. Cursively eliminates a ton of overhead found in libraries such as CsvHelper by restricting the allowed input encodings and using the visitor pattern as its only means of output. Cursively can scan through the original bytes of the input to do its work, and it can give slices of the input data directly to the consumer without having to copy or allocate. Therefore, these benchmarks are somewhat biased in favor of Cursively, as CsvHelper relies on external code to transform the data to UTF-16. This isn't as unfair as that makes it sound: the overwhelming majority of input files are probably UTF-8 anyway (or a compatible SBCS), so this transformation is something that practically every user will experience. Input files can be found here: https://github.com/airbreather/Cursively/tree/v1.1.0/test/Cursively.Benchmark/large-csv-files.zip Benchmark source code is this: https://github.com/airbreather/Cursively/tree/v1.1.0/test/Cursively.Benchmark Raw BenchmarkDotNet output is at the bottom, but here are some numbers derived from it. The data was fully loaded in main memory when running these tests. This summary also does not indicate anything about the GC pressure: CSV File Runtime Library Throughput 100 records / 10,000 tiny fields each .NET 4.7.2 Cursively 336.06 MiB/s 100 records / 10,000 tiny fields each .NET 4.7.2 CsvHelper 22.04 MiB/s 100 records / 10,000 tiny fields each .NET Core 2.2.5 Cursively 487.59 MiB/s 100 records / 10,000 tiny fields each .NET Core 2.2.5 CsvHelper 27.31 MiB/s 100 records / 10,000 tiny quoted fields each .NET 4.7.2 Cursively 178.23 MiB/s 100 records / 10,000 tiny quoted fields each .NET 4.7.2 CsvHelper 24.33 MiB/s 100 records / 10,000 tiny quoted fields each .NET Core 2.2.5 Cursively 303.67 MiB/s 100 records / 10,000 tiny quoted fields each .NET Core 2.2.5 CsvHelper 29.20 MiB/s 10,000 records / 1,000 empty fields each .NET 4.7.2 Cursively 176.71 MiB/s 10,000 records / 1,000 empty fields each .NET 4.7.2 CsvHelper 14.45 MiB/s 10,000 records / 1,000 empty fields each .NET Core 2.2.5 Cursively 306.49 MiB/s 10,000 records / 1,000 empty fields each .NET Core 2.2.5 CsvHelper 15.15 MiB/s Mock data from Mockaroo .NET 4.7.2 Cursively 2,711.41 MiB/s Mock data from Mockaroo .NET 4.7.2 CsvHelper 72.50 MiB/s Mock data from Mockaroo .NET Core 2.2.5 Cursively 3,755.55 MiB/s Mock data from Mockaroo .NET Core 2.2.5 CsvHelper 75.05 MiB/s worldcitiespop.csv ( from here ) .NET 4.7.2 Cursively 390.75 MiB/s worldcitiespop.csv ( from here ) .NET 4.7.2 CsvHelper 40.15 MiB/s worldcitiespop.csv ( from here ) .NET Core 2.2.5 Cursively 607.81 MiB/s worldcitiespop.csv ( from here ) .NET Core 2.2.5 CsvHelper 39.90 MiB/s Raw BenchmarkDotNet output: BenchmarkDotNet=v0.11.5, OS=Windows 10.0.18362 Intel Core i7-6850K CPU 3.60GHz (Skylake), 1 CPU, 12 logical and 6 physical cores .NET Core SDK=3.0.100-preview6-012264 [Host] : .NET Core 2.2.5 (CoreCLR 4.6.27617.05, CoreFX 4.6.27618.01), 64bit RyuJIT Job-DDQSKN : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.8.3801.0 Job-RTHUVO : .NET Core 2.2.5 (CoreCLR 4.6.27617.05, CoreFX 4.6.27618.01), 64bit RyuJIT Server=True Method Runtime csvFile Mean Error StdDev Ratio RatioSD Gen 0 Gen 1 Gen 2 Allocated CountRowsUsingCursively Clr 100-huge-records 8.231 ms 0.0839 ms 0.0743 ms 1.00 0.00 - - - 128 B CountRowsUsingCsvHelper Clr 100-huge-records 125.493 ms 1.1717 ms 1.0387 ms 15.25 0.21 17250.0000 6750.0000 750.0000 110560856 B CountRowsUsingCursively Core 100-huge-records 5.673 ms 0.0073 ms 0.0068 ms 1.00 0.00 - - - 48 B CountRowsUsingCsvHelper Core 100-huge-records 101.277 ms 0.2342 ms 0.2190 ms 17.85 0.05 400.0000 200.0000 - 110256320 B CountRowsUsingCursively Clr 100-h(...)uoted [23] 26.222 ms 0.0260 ms 0.0231 ms 1.00 0.00 - - - 256 B CountRowsUsingCsvHelper Clr 100-h(...)uoted [23] 192.090 ms 0.9954 ms 0.9311 ms 7.33 0.04 25000.0000 11000.0000 666.6667 154027456 B CountRowsUsingCursively Core 100-h(...)uoted [23] 15.390 ms 0.0450 ms 0.0399 ms 1.00 0.00 - - - 48 B CountRowsUsingCsvHelper Core 100-h(...)uoted [23] 160.043 ms 0.4644 ms 0.4344 ms 10.40 0.04 333.3333 - - 153579848 B CountRowsUsingCursively Clr 10k-empty-records 54.007 ms 0.3061 ms 0.2556 ms 1.00 0.00 - - - 819 B CountRowsUsingCsvHelper Clr 10k-empty-records 661.502 ms 3.1801 ms 2.9747 ms 12.24 0.08 66000.0000 2000.0000 - 422077104 B CountRowsUsingCursively Core 10k-empty-records 31.178 ms 0.2056 ms 0.1924 ms 1.00 0.00 - - - 48 B CountRowsUsingCsvHelper Core 10k-empty-records 630.683 ms 1.2503 ms 1.1084 ms 20.23 0.13 2000.0000 - - 420832856 B CountRowsUsingCursively Clr mocked 4.478 ms 0.0071 ms 0.0067 ms 1.00 0.00 - - - 64 B CountRowsUsingCsvHelper Clr mocked 167.477 ms 0.3523 ms 0.3296 ms 37.40 0.08 18333.3333 333.3333 - 116105312 B CountRowsUsingCursively Core mocked 3.233 ms 0.0063 ms 0.0059 ms 1.00 0.00 - - - 48 B CountRowsUsingCsvHelper Core mocked 161.791 ms 0.3473 ms 0.3249 ms 50.05 0.15 333.3333 - - 115757736 B CountRowsUsingCursively Clr worldcitiespop 369.738 ms 0.6855 ms 0.6077 ms 1.00 0.00 - - - 8192 B CountRowsUsingCsvHelper Clr worldcitiespop 3,598.421 ms 2.0735 ms 1.9396 ms 9.73 0.02 493000.0000 7000.0000 - 3105811440 B CountRowsUsingCursively Core worldcitiespop 237.695 ms 0.2994 ms 0.2800 ms 1.00 0.00 - - - 48 B CountRowsUsingCsvHelper Core worldcitiespop 3,620.550 ms 3.1766 ms 2.8160 ms 15.23 0.02 15000.0000 - - 3096694312 B"
  },
  "benchmark-1.0.0.html": {
    "href": "benchmark-1.0.0.html",
    "title": "| Cursively",
    "keywords": "This benchmark tests the simple act of counting how many records are in a CSV file. It's not a simple count of how many lines are in the text file: line breaks within quoted fields must be treated as data, and multiple line breaks in a row must be treated as one, since each record must have at least one field. Therefore, assuming correct implementations, this benchmark should test the raw CSV processing speed. Cursively eliminates a ton of overhead found in libraries such as CsvHelper by restricting the allowed input encodings and using the visitor pattern as its only means of output. Cursively can scan through the original bytes of the input to do its work, and it can give slices of the input data directly to the consumer without having to copy or allocate. Therefore, these benchmarks are somewhat biased in favor of Cursively, as CsvHelper relies on external code to transform the data to UTF-16. This isn't as unfair as that makes it sound: the overwhelming majority of input files are probably UTF-8 anyway (or a compatible SBCS), so this transformation is something that practically every user will experience. Input files can be found here: https://github.com/airbreather/Cursively/tree/v1.0.0/test/Cursively.Benchmark/large-csv-files Benchmark source code is a slightly edited* version of this: https://github.com/airbreather/Cursively/tree/v1.0.0/test/Cursively.Benchmark *edited only to remove CoreRtJob and the more-or-less redundant NopUsingCursively Raw BenchmarkDotNet output is at the bottom, but here are some numbers derived from it. The data was fully loaded in main memory when running these tests. This summary also does not indicate anything about the GC pressure: CSV File Runtime Library Throughput 100 records / 10,000 tiny fields each .NET 4.7.2 Cursively 99.81 MiB/s 100 records / 10,000 tiny fields each .NET 4.7.2 CsvHelper 22.60 MiB/s 100 records / 10,000 tiny fields each .NET Core 2.2.5 Cursively 126.1 MiB/s 100 records / 10,000 tiny fields each .NET Core 2.2.5 CsvHelper 25.32 MiB/s 100 records / 10,000 tiny quoted fields each .NET 4.7.2 Cursively 118.5 MiB/s 100 records / 10,000 tiny quoted fields each .NET 4.7.2 CsvHelper 25.05 MiB/s 100 records / 10,000 tiny quoted fields each .NET Core 2.2.5 Cursively 187.0 MiB/s 100 records / 10,000 tiny quoted fields each .NET Core 2.2.5 CsvHelper 27.96 MiB/s 10,000 records / 1,000 empty fields each .NET 4.7.2 Cursively 64.15 MiB/s 10,000 records / 1,000 empty fields each .NET 4.7.2 CsvHelper 15.57 MiB/s 10,000 records / 1,000 empty fields each .NET Core 2.2.5 Cursively 112.7 MiB/s 10,000 records / 1,000 empty fields each .NET Core 2.2.5 CsvHelper 14.84 MiB/s Mock data from Mockaroo .NET 4.7.2 Cursively 1.637 GiB/s Mock data from Mockaroo .NET 4.7.2 CsvHelper 74.81 MiB/s Mock data from Mockaroo .NET Core 2.2.5 Cursively 1.893 GiB/s Mock data from Mockaroo .NET Core 2.2.5 CsvHelper 66.86 MiB/s Raw BenchmarkDotNet output: BenchmarkDotNet=v0.11.5, OS=Windows 10.0.17134.765 (1803/April2018Update/Redstone4) Intel Core i7-6850K CPU 3.60GHz (Skylake), 1 CPU, 12 logical and 6 physical cores Frequency=3515622 Hz, Resolution=284.4447 ns, Timer=TSC .NET Core SDK=2.2.300 [Host] : .NET Core 2.2.5 (CoreCLR 4.6.27617.05, CoreFX 4.6.27618.01), 64bit RyuJIT Job-ASLTDW : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3416.0 Job-RICADF : .NET Core 2.2.5 (CoreCLR 4.6.27617.05, CoreFX 4.6.27618.01), 64bit RyuJIT Server=True Method Runtime csvFile Mean Error StdDev Ratio RatioSD Gen 0 Gen 1 Gen 2 Allocated CountRowsUsingCursively Clr 100-huge-records 27.714 ms 0.0126 ms 0.0105 ms 1.00 0.00 - - - 256 B CountRowsUsingCsvHelper Clr 100-huge-records 122.397 ms 0.1685 ms 0.1494 ms 4.42 0.01 17250.0000 6250.0000 750.0000 110257334 B CountRowsUsingCursively Core 100-huge-records 21.932 ms 0.0254 ms 0.0226 ms 1.00 0.00 - - - 56 B CountRowsUsingCsvHelper Core 100-huge-records 109.261 ms 0.3319 ms 0.3104 ms 4.98 0.02 400.0000 200.0000 - 110256320 B CountRowsUsingCursively Clr 100-h(...)uoted [23] 39.453 ms 0.0974 ms 0.0864 ms 1.00 0.00 - - - 683 B CountRowsUsingCsvHelper Clr 100-h(...)uoted [23] 186.572 ms 0.4682 ms 0.4380 ms 4.73 0.01 24666.6667 9666.6667 666.6667 153595995 B CountRowsUsingCursively Core 100-h(...)uoted [23] 24.995 ms 0.0160 ms 0.0142 ms 1.00 0.00 - - - 56 B CountRowsUsingCsvHelper Core 100-h(...)uoted [23] 167.160 ms 0.3437 ms 0.3215 ms 6.69 0.02 333.3333 - - 153579848 B CountRowsUsingCursively Clr 10k-empty-records 148.952 ms 0.2502 ms 0.2340 ms 1.00 0.00 - - - 2048 B CountRowsUsingCsvHelper Clr 10k-empty-records 613.718 ms 0.8869 ms 0.7862 ms 4.12 0.01 66000.0000 2000.0000 - 420838944 B CountRowsUsingCursively Core 10k-empty-records 84.801 ms 0.1079 ms 0.1009 ms 1.00 0.00 - - - 56 B CountRowsUsingCsvHelper Core 10k-empty-records 644.051 ms 2.8782 ms 2.5515 ms 7.60 0.03 2000.0000 - - 420832856 B CountRowsUsingCursively Clr mocked 7.242 ms 0.0233 ms 0.0207 ms 1.00 0.00 - - - 64 B CountRowsUsingCsvHelper Clr mocked 162.298 ms 0.2958 ms 0.2622 ms 22.41 0.08 18000.0000 333.3333 - 115764389 B CountRowsUsingCursively Core mocked 6.264 ms 0.0115 ms 0.0107 ms 1.00 0.00 - - - 56 B CountRowsUsingCsvHelper Core mocked 181.592 ms 0.3413 ms 0.3193 ms 28.99 0.09 333.3333 - - 115757736 B"
  },
  "api/Cursively.html": {
    "href": "api/Cursively.html",
    "title": "Namespace Cursively | Cursively",
    "keywords": "Namespace Cursively Classes Csv Contains helper methods for CSV processing. CsvAsyncInput Helpers to create inputs that describe CSV data streams asynchronously. CsvReaderVisitorBase Base class for listeners that process a stream of RFC 4180 (CSV) tokens from an instance of CsvTokenizer . CsvReaderVisitorWithUTF8HeadersBase Intermediate base class for CSV reader visitors that don't want to have to implement header handling by themselves. Instances of this class are tied to a single CSV stream and cannot be reused or reset for use with other CSV streams. Each instance of this visitor has an upper-bound on the maximum number of headers and on the maximum length of each header. CSV streams that exceed these limits will cause this class to throw exceptions, and behavior of a particular instance is undefined once this happens. CsvSyncInput Helpers to create inputs that describe CSV data streams synchronously. CsvTokenizer Tokenizes a byte stream into CSV fields. The processing follows the guidelines set out in RFC 4180 unless and until the stream proves to be in an incompatible format, in which case a set of additional rules kick in to ensure that all streams are still compatible. The byte stream is tokenized according to the rules of the ASCII encoding. This makes it compatible with any encoding that encodes 0x0A, 0x0D, 0x22, and 0x2C the same way that ASCII encodes them. UTF-8 and Extended ASCII SBCS are notable examples of acceptable encodings. UTF-16 is a notable example of an unacceptable encoding; trying to use this class to process text encoded in an unacceptable encoding will yield undesirable results without any errors. All bytes that appear in the stream except 0x0A, 0x0D, 0x22, and 0x2C are unconditionally treated as data and passed through as-is. It is the consumer's responsibility to handle (or not handle) NUL bytes, invalid UTF-8, leading UTF-8 BOM, or any other quirks that come with the territory of text processing. CursivelyDataStreamException Serves as the base class for exceptions thrown by this library to indicate problems with the actual contents of a CSV stream. CursivelyExtraDataFieldsException Raised by CsvReaderVisitorWithUTF8HeadersBase , by default, when a data record contains more fields than the header record. CursivelyHeaderIsTooLongException Raised by CsvReaderVisitorWithUTF8HeadersBase when the length of a header exceeds the configured maximum. CursivelyHeadersAreNotUTF8Exception Raised by CsvReaderVisitorWithUTF8HeadersBase , by default, when the header record contains invalid UTF-8 bytes. CursivelyMissingDataFieldsException Raised by CsvReaderVisitorWithUTF8HeadersBase , by default, when a data record contains fewer fields than the header record. CursivelyTooManyHeadersException Raised by CsvReaderVisitorWithUTF8HeadersBase when the number of headers exceeds the configured maximum."
  },
  "api/Cursively.Inputs.html": {
    "href": "api/Cursively.Inputs.html",
    "title": "Namespace Cursively.Inputs | Cursively",
    "keywords": "Namespace Cursively.Inputs Classes CsvAsyncInputBase Models a CSV source data stream that can be processed asynchronously. CsvAsyncStreamInput Implementation of CsvAsyncInputBase backed by a Stream . CsvMemoryMappedFileInput Implementation of CsvSyncInputBase backed by a file from the filesystem that will be processed by mapping it into virtual memory and then treating it like a contiguous array of bytes. CsvPipeReaderInput Implementation of CsvAsyncInputBase backed by a PipeReader . CsvReadOnlyMemoryInput Implementation of CsvSyncInputBase backed by a ReadOnlyMemory<T> of bytes. CsvReadOnlySequenceInput Implementation of CsvSyncInputBase backed by a ReadOnlySequence<T> of bytes. CsvSyncInputBase Models a CSV source data stream that can be processed synchronously. CsvSyncStreamInput Implementation of CsvSyncInputBase backed by a Stream ."
  },
  "api/Cursively.Inputs.CsvSyncStreamInput.html": {
    "href": "api/Cursively.Inputs.CsvSyncStreamInput.html",
    "title": "Class CsvSyncStreamInput | Cursively",
    "keywords": "Class CsvSyncStreamInput Implementation of CsvSyncInputBase backed by a Stream . Inheritance Object CsvSyncInputBase CsvSyncStreamInput Inherited Members CsvSyncInputBase.Process(CsvReaderVisitorBase) CsvSyncInputBase.ThrowIfProcessingHasAlreadyStarted() Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively.Inputs Assembly : Cursively.dll Syntax public sealed class CsvSyncStreamInput : CsvSyncInputBase Methods | Improve this Doc View Source ProcessCore(CsvReaderVisitorBase) Implements the inner logic for Process(CsvReaderVisitorBase) . Declaration protected override void ProcessCore(CsvReaderVisitorBase visitor) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to describe this CSV data stream to. Overrides CsvSyncInputBase.ProcessCore(CsvReaderVisitorBase) Remarks The base class will call this method at most once per instance. | Improve this Doc View Source WithDelimiter(Byte) Creates a new instance of the CsvSyncStreamInput class as a copy of this one, with the given delimiter. Declaration public CsvSyncStreamInput WithDelimiter(byte delimiter) Parameters Type Name Description Byte delimiter The delimiter to use. Use IsValidDelimiter(Byte) to test whether or not a particular value is valid. Returns Type Description CsvSyncStreamInput A new instance of the CsvSyncStreamInput class as a copy of this one, with the given delimiter. Exceptions Type Condition ArgumentException Thrown when delimiter is one of the illegal values. InvalidOperationException Thrown when Process(CsvReaderVisitorBase) has already been called. | Improve this Doc View Source WithIgnoreUTF8ByteOrderMark(Boolean) Creates a new instance of the CsvSyncStreamInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Declaration public CsvSyncStreamInput WithIgnoreUTF8ByteOrderMark(bool ignoreUTF8ByteOrderMark) Parameters Type Name Description Boolean ignoreUTF8ByteOrderMark A value indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Returns Type Description CsvSyncStreamInput A new instance of the CsvSyncStreamInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Exceptions Type Condition InvalidOperationException Thrown when Process(CsvReaderVisitorBase) has already been called. | Improve this Doc View Source WithMinReadBufferByteCount(Int32) Creates a new instance of the CsvSyncStreamInput class as a copy of this one, reading in chunks of sizes that are at least the given number of bytes. Declaration public CsvSyncStreamInput WithMinReadBufferByteCount(int minReadBufferByteCount) Parameters Type Name Description Int32 minReadBufferByteCount The minimum size, in bytes, of chunks to read from the buffer. When using an ArrayPool<T> , this is the value that will be used for Rent(Int32) , so larger chunks should be expected. When not using an ArrayPool<T> (i.e., on instances configured by calling WithReadBufferPool(ArrayPool<Byte>) passing in null ), this is the actual size of any arrays that will be allocated on the managed heap. Returns Type Description CsvSyncStreamInput A new instance of the CsvSyncStreamInput class as a copy of this one, using the given ArrayPool<T> to provide temporary buffers for the Stream to read into. Exceptions Type Condition ArgumentOutOfRangeException Thrown when minReadBufferByteCount is not greater than zero. InvalidOperationException Thrown when Process(CsvReaderVisitorBase) has already been called. | Improve this Doc View Source WithReadBufferPool(ArrayPool<Byte>) Creates a new instance of the CsvSyncStreamInput class as a copy of this one, using the given ArrayPool<T> to provide temporary buffers for the Stream to read into. Declaration public CsvSyncStreamInput WithReadBufferPool(ArrayPool<byte> readBufferPool) Parameters Type Name Description ArrayPool < Byte > readBufferPool The ArrayPool<T> to provide temporary buffers for the Stream to read into, or null if the temporary buffers should be allocated directly on the managed heap. Returns Type Description CsvSyncStreamInput A new instance of the CsvSyncStreamInput class as a copy of this one, using the given ArrayPool<T> to provide temporary buffers for the Stream to read into. Exceptions Type Condition InvalidOperationException Thrown when Process(CsvReaderVisitorBase) has already been called."
  },
  "api/Cursively.Inputs.CsvSyncInputBase.html": {
    "href": "api/Cursively.Inputs.CsvSyncInputBase.html",
    "title": "Class CsvSyncInputBase | Cursively",
    "keywords": "Class CsvSyncInputBase Models a CSV source data stream that can be processed synchronously. Inheritance Object CsvSyncInputBase CsvMemoryMappedFileInput CsvReadOnlyMemoryInput CsvReadOnlySequenceInput CsvSyncStreamInput Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively.Inputs Assembly : Cursively.dll Syntax public abstract class CsvSyncInputBase Methods | Improve this Doc View Source Process(CsvReaderVisitorBase) Describes the contents of this CSV data stream to a CsvReaderVisitorBase . Declaration public void Process(CsvReaderVisitorBase visitor) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to describe this CSV data stream to. Exceptions Type Condition InvalidOperationException Thrown when this stream has already been processed. | Improve this Doc View Source ProcessCore(CsvReaderVisitorBase) Implements the inner logic for Process(CsvReaderVisitorBase) . Declaration protected abstract void ProcessCore(CsvReaderVisitorBase visitor) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to describe this CSV data stream to. Remarks The base class will call this method at most once per instance. | Improve this Doc View Source ThrowIfProcessingHasAlreadyStarted() Throws if Process(CsvReaderVisitorBase) has already been called for this instance. Declaration protected void ThrowIfProcessingHasAlreadyStarted()"
  },
  "api/Cursively.Inputs.CsvReadOnlySequenceInput.html": {
    "href": "api/Cursively.Inputs.CsvReadOnlySequenceInput.html",
    "title": "Class CsvReadOnlySequenceInput | Cursively",
    "keywords": "Class CsvReadOnlySequenceInput Implementation of CsvSyncInputBase backed by a ReadOnlySequence<T> of bytes. Inheritance Object CsvSyncInputBase CsvReadOnlySequenceInput Inherited Members CsvSyncInputBase.Process(CsvReaderVisitorBase) CsvSyncInputBase.ThrowIfProcessingHasAlreadyStarted() Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively.Inputs Assembly : Cursively.dll Syntax public sealed class CsvReadOnlySequenceInput : CsvSyncInputBase Methods | Improve this Doc View Source ProcessCore(CsvReaderVisitorBase) Implements the inner logic for Process(CsvReaderVisitorBase) . Declaration protected override void ProcessCore(CsvReaderVisitorBase visitor) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to describe this CSV data stream to. Overrides CsvSyncInputBase.ProcessCore(CsvReaderVisitorBase) Remarks The base class will call this method at most once per instance. | Improve this Doc View Source WithDelimiter(Byte) Creates a new instance of the CsvReadOnlySequenceInput class as a copy of this one, with the given delimiter. Declaration public CsvReadOnlySequenceInput WithDelimiter(byte delimiter) Parameters Type Name Description Byte delimiter The delimiter to use. Use IsValidDelimiter(Byte) to test whether or not a particular value is valid. Returns Type Description CsvReadOnlySequenceInput A new instance of the CsvReadOnlySequenceInput class as a copy of this one, with the given delimiter. Exceptions Type Condition ArgumentException Thrown when delimiter is one of the illegal values. InvalidOperationException Thrown when Process(CsvReaderVisitorBase) has already been called. | Improve this Doc View Source WithIgnoreUTF8ByteOrderMark(Boolean) Creates a new instance of the CsvReadOnlySequenceInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Declaration public CsvReadOnlySequenceInput WithIgnoreUTF8ByteOrderMark(bool ignoreUTF8ByteOrderMark) Parameters Type Name Description Boolean ignoreUTF8ByteOrderMark A value indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Returns Type Description CsvReadOnlySequenceInput A new instance of the CsvReadOnlySequenceInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Exceptions Type Condition InvalidOperationException Thrown when Process(CsvReaderVisitorBase) has already been called."
  },
  "api/Cursively.Inputs.CsvReadOnlyMemoryInput.html": {
    "href": "api/Cursively.Inputs.CsvReadOnlyMemoryInput.html",
    "title": "Class CsvReadOnlyMemoryInput | Cursively",
    "keywords": "Class CsvReadOnlyMemoryInput Implementation of CsvSyncInputBase backed by a ReadOnlyMemory<T> of bytes. Inheritance Object CsvSyncInputBase CsvReadOnlyMemoryInput Inherited Members CsvSyncInputBase.Process(CsvReaderVisitorBase) CsvSyncInputBase.ThrowIfProcessingHasAlreadyStarted() Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively.Inputs Assembly : Cursively.dll Syntax public sealed class CsvReadOnlyMemoryInput : CsvSyncInputBase Methods | Improve this Doc View Source ProcessCore(CsvReaderVisitorBase) Implements the inner logic for Process(CsvReaderVisitorBase) . Declaration protected override void ProcessCore(CsvReaderVisitorBase visitor) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to describe this CSV data stream to. Overrides CsvSyncInputBase.ProcessCore(CsvReaderVisitorBase) Remarks The base class will call this method at most once per instance. | Improve this Doc View Source WithDelimiter(Byte) Creates a new instance of the CsvReadOnlyMemoryInput class as a copy of this one, with the given delimiter. Declaration public CsvReadOnlyMemoryInput WithDelimiter(byte delimiter) Parameters Type Name Description Byte delimiter The delimiter to use. Use IsValidDelimiter(Byte) to test whether or not a particular value is valid. Returns Type Description CsvReadOnlyMemoryInput A new instance of the CsvReadOnlyMemoryInput class as a copy of this one, with the given delimiter. Exceptions Type Condition ArgumentException Thrown when delimiter is one of the illegal values. InvalidOperationException Thrown when Process(CsvReaderVisitorBase) has already been called. | Improve this Doc View Source WithIgnoreUTF8ByteOrderMark(Boolean) Creates a new instance of the CsvReadOnlyMemoryInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Declaration public CsvReadOnlyMemoryInput WithIgnoreUTF8ByteOrderMark(bool ignoreUTF8ByteOrderMark) Parameters Type Name Description Boolean ignoreUTF8ByteOrderMark A value indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Returns Type Description CsvReadOnlyMemoryInput A new instance of the CsvReadOnlyMemoryInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Exceptions Type Condition InvalidOperationException Thrown when Process(CsvReaderVisitorBase) has already been called."
  },
  "api/Cursively.Inputs.CsvPipeReaderInput.html": {
    "href": "api/Cursively.Inputs.CsvPipeReaderInput.html",
    "title": "Class CsvPipeReaderInput | Cursively",
    "keywords": "Class CsvPipeReaderInput Implementation of CsvAsyncInputBase backed by a PipeReader . Inheritance Object CsvAsyncInputBase CsvPipeReaderInput Inherited Members CsvAsyncInputBase.ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) CsvAsyncInputBase.ThrowIfProcessingHasAlreadyStarted() Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively.Inputs Assembly : Cursively.dll Syntax public sealed class CsvPipeReaderInput : CsvAsyncInputBase Methods | Improve this Doc View Source ProcessAsyncCore(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) Implements the inner logic for ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) . Declaration protected override ValueTask ProcessAsyncCore(CsvReaderVisitorBase visitor, IProgress<int> progress, CancellationToken cancellationToken) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to describe this CSV data stream to. IProgress < Int32 > progress An optional IProgress<T> instance that will receive a report of the size of each chunk (in bytes) as processing finishes, followed by one more report with a zero when the last chunk in the stream has been processed. CancellationToken cancellationToken An optional CancellationToken that may be used to signal cancellation. Returns Type Description ValueTask A ValueTask encapsulating the operation. Overrides CsvAsyncInputBase.ProcessAsyncCore(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) Exceptions Type Condition InvalidOperationException Thrown when this stream has already been processed. OperationCanceledException Thrown to acknowledge a canceled cancellationToken . Some subclasses may throw an instance of a subclass, such as TaskCanceledException . | Improve this Doc View Source WithDelimiter(Byte) Creates a new instance of the CsvPipeReaderInput class as a copy of this one, with the given delimiter. Declaration public CsvPipeReaderInput WithDelimiter(byte delimiter) Parameters Type Name Description Byte delimiter The delimiter to use. Use IsValidDelimiter(Byte) to test whether or not a particular value is valid. Returns Type Description CsvPipeReaderInput A new instance of the CsvPipeReaderInput class as a copy of this one, with the given delimiter. Exceptions Type Condition ArgumentException Thrown when delimiter is one of the illegal values. InvalidOperationException Thrown when ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) has already been called. | Improve this Doc View Source WithIgnoreUTF8ByteOrderMark(Boolean) Creates a new instance of the CsvPipeReaderInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Declaration public CsvPipeReaderInput WithIgnoreUTF8ByteOrderMark(bool ignoreUTF8ByteOrderMark) Parameters Type Name Description Boolean ignoreUTF8ByteOrderMark A value indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Returns Type Description CsvPipeReaderInput A new instance of the CsvPipeReaderInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Exceptions Type Condition InvalidOperationException Thrown when ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) has already been called."
  },
  "api/Cursively.Inputs.CsvMemoryMappedFileInput.html": {
    "href": "api/Cursively.Inputs.CsvMemoryMappedFileInput.html",
    "title": "Class CsvMemoryMappedFileInput | Cursively",
    "keywords": "Class CsvMemoryMappedFileInput Implementation of CsvSyncInputBase backed by a file from the filesystem that will be processed by mapping it into virtual memory and then treating it like a contiguous array of bytes. Inheritance Object CsvSyncInputBase CsvMemoryMappedFileInput Inherited Members CsvSyncInputBase.Process(CsvReaderVisitorBase) CsvSyncInputBase.ThrowIfProcessingHasAlreadyStarted() Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively.Inputs Assembly : Cursively.dll Syntax public sealed class CsvMemoryMappedFileInput : CsvSyncInputBase Methods | Improve this Doc View Source ProcessCore(CsvReaderVisitorBase) Implements the inner logic for Process(CsvReaderVisitorBase) . Declaration protected override void ProcessCore(CsvReaderVisitorBase visitor) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to describe this CSV data stream to. Overrides CsvSyncInputBase.ProcessCore(CsvReaderVisitorBase) Remarks The base class will call this method at most once per instance. | Improve this Doc View Source WithDelimiter(Byte) Creates a new instance of the CsvMemoryMappedFileInput class as a copy of this one, with the given delimiter. Declaration public CsvMemoryMappedFileInput WithDelimiter(byte delimiter) Parameters Type Name Description Byte delimiter The delimiter to use. Use IsValidDelimiter(Byte) to test whether or not a particular value is valid. Returns Type Description CsvMemoryMappedFileInput A new instance of the CsvMemoryMappedFileInput class as a copy of this one, with the given delimiter. Exceptions Type Condition ArgumentException Thrown when delimiter is one of the illegal values. InvalidOperationException Thrown when Process(CsvReaderVisitorBase) has already been called. | Improve this Doc View Source WithIgnoreUTF8ByteOrderMark(Boolean) Creates a new instance of the CsvReadOnlyMemoryInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Declaration public CsvMemoryMappedFileInput WithIgnoreUTF8ByteOrderMark(bool ignoreUTF8ByteOrderMark) Parameters Type Name Description Boolean ignoreUTF8ByteOrderMark A value indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Returns Type Description CsvMemoryMappedFileInput A new instance of the CsvReadOnlyMemoryInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Exceptions Type Condition InvalidOperationException Thrown when Process(CsvReaderVisitorBase) has already been called."
  },
  "api/Cursively.Inputs.CsvAsyncStreamInput.html": {
    "href": "api/Cursively.Inputs.CsvAsyncStreamInput.html",
    "title": "Class CsvAsyncStreamInput | Cursively",
    "keywords": "Class CsvAsyncStreamInput Implementation of CsvAsyncInputBase backed by a Stream . Inheritance Object CsvAsyncInputBase CsvAsyncStreamInput Inherited Members CsvAsyncInputBase.ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) CsvAsyncInputBase.ThrowIfProcessingHasAlreadyStarted() Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively.Inputs Assembly : Cursively.dll Syntax public sealed class CsvAsyncStreamInput : CsvAsyncInputBase Methods | Improve this Doc View Source ProcessAsyncCore(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) Implements the inner logic for ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) . Declaration protected override ValueTask ProcessAsyncCore(CsvReaderVisitorBase visitor, IProgress<int> progress, CancellationToken cancellationToken) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to describe this CSV data stream to. IProgress < Int32 > progress An optional IProgress<T> instance that will receive a report of the size of each chunk (in bytes) as processing finishes, followed by one more report with a zero when the last chunk in the stream has been processed. CancellationToken cancellationToken An optional CancellationToken that may be used to signal cancellation. Returns Type Description ValueTask A ValueTask encapsulating the operation. Overrides CsvAsyncInputBase.ProcessAsyncCore(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) Exceptions Type Condition InvalidOperationException Thrown when this stream has already been processed. OperationCanceledException Thrown to acknowledge a canceled cancellationToken . Some subclasses may throw an instance of a subclass, such as TaskCanceledException . | Improve this Doc View Source WithDelimiter(Byte) Creates a new instance of the CsvAsyncStreamInput class as a copy of this one, with the given delimiter. Declaration public CsvAsyncStreamInput WithDelimiter(byte delimiter) Parameters Type Name Description Byte delimiter The delimiter to use. Use IsValidDelimiter(Byte) to test whether or not a particular value is valid. Returns Type Description CsvAsyncStreamInput A new instance of the CsvAsyncStreamInput class as a copy of this one, with the given delimiter. Exceptions Type Condition ArgumentException Thrown when delimiter is one of the illegal values. InvalidOperationException Thrown when ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) has already been called. | Improve this Doc View Source WithIgnoreUTF8ByteOrderMark(Boolean) Creates a new instance of the CsvAsyncStreamInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Declaration public CsvAsyncStreamInput WithIgnoreUTF8ByteOrderMark(bool ignoreUTF8ByteOrderMark) Parameters Type Name Description Boolean ignoreUTF8ByteOrderMark A value indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Returns Type Description CsvAsyncStreamInput A new instance of the CsvAsyncStreamInput class as a copy of this one, with the given flag indicating whether or not a leading UTF-8 byte order mark, if present, should be omitted from the first field's data. Exceptions Type Condition InvalidOperationException Thrown when ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) has already been called. | Improve this Doc View Source WithMinReadBufferByteCount(Int32) Creates a new instance of the CsvAsyncStreamInput class as a copy of this one, reading in chunks of sizes that are at least the given number of bytes. Declaration public CsvAsyncStreamInput WithMinReadBufferByteCount(int minReadBufferByteCount) Parameters Type Name Description Int32 minReadBufferByteCount The minimum size, in bytes, of chunks to read from the buffer. When using an ArrayPool<T> , this is the value that will be used for Rent(Int32) , so larger chunks should be expected. When not using an ArrayPool<T> (i.e., on instances configured by calling WithReadBufferPool(ArrayPool<Byte>) passing in null ), this is the actual size of any arrays that will be allocated on the managed heap. Returns Type Description CsvAsyncStreamInput A new instance of the CsvAsyncStreamInput class as a copy of this one, using the given ArrayPool<T> to provide temporary buffers for the Stream to read into. Exceptions Type Condition ArgumentOutOfRangeException Thrown when minReadBufferByteCount is not greater than zero. InvalidOperationException Thrown when ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) has already been called. | Improve this Doc View Source WithReadBufferPool(ArrayPool<Byte>) Creates a new instance of the CsvAsyncStreamInput class as a copy of this one, using the given ArrayPool<T> to provide temporary buffers for the Stream to read into. Declaration public CsvAsyncStreamInput WithReadBufferPool(ArrayPool<byte> readBufferPool) Parameters Type Name Description ArrayPool < Byte > readBufferPool The ArrayPool<T> to provide temporary buffers for the Stream to read into, or null if the temporary buffers should be allocated directly on the managed heap. Returns Type Description CsvAsyncStreamInput A new instance of the CsvAsyncStreamInput class as a copy of this one, using the given ArrayPool<T> to provide temporary buffers for the Stream to read into. Exceptions Type Condition InvalidOperationException Thrown when ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) has already been called."
  },
  "api/Cursively.Inputs.CsvAsyncInputBase.html": {
    "href": "api/Cursively.Inputs.CsvAsyncInputBase.html",
    "title": "Class CsvAsyncInputBase | Cursively",
    "keywords": "Class CsvAsyncInputBase Models a CSV source data stream that can be processed asynchronously. Inheritance Object CsvAsyncInputBase CsvAsyncStreamInput CsvPipeReaderInput Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively.Inputs Assembly : Cursively.dll Syntax public abstract class CsvAsyncInputBase Methods | Improve this Doc View Source ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) Describes the contents of this CSV data stream to a CsvReaderVisitorBase . Declaration public ValueTask ProcessAsync(CsvReaderVisitorBase visitor, IProgress<int> progress = null, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to describe this CSV data stream to. IProgress < Int32 > progress An optional IProgress<T> instance that will receive a report of the size of each chunk (in bytes) as processing finishes, followed by one more report with a zero when the last chunk in the stream has been processed. CancellationToken cancellationToken An optional CancellationToken that may be used to signal cancellation. Returns Type Description ValueTask A ValueTask encapsulating the operation. Exceptions Type Condition InvalidOperationException Thrown when this stream has already been processed. OperationCanceledException Thrown to acknowledge a canceled cancellationToken . Some subclasses may throw an instance of a subclass, such as TaskCanceledException . | Improve this Doc View Source ProcessAsyncCore(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) Implements the inner logic for ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) . Declaration protected abstract ValueTask ProcessAsyncCore(CsvReaderVisitorBase visitor, IProgress<int> progress, CancellationToken cancellationToken) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to describe this CSV data stream to. IProgress < Int32 > progress An optional IProgress<T> instance that will receive a report of the size of each chunk (in bytes) as processing finishes, followed by one more report with a zero when the last chunk in the stream has been processed. CancellationToken cancellationToken An optional CancellationToken that may be used to signal cancellation. Returns Type Description ValueTask A ValueTask encapsulating the operation. Exceptions Type Condition InvalidOperationException Thrown when this stream has already been processed. OperationCanceledException Thrown to acknowledge a canceled cancellationToken . Some subclasses may throw an instance of a subclass, such as TaskCanceledException . | Improve this Doc View Source ThrowIfProcessingHasAlreadyStarted() Throws if ProcessAsync(CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) has already been called for this instance. Declaration protected void ThrowIfProcessingHasAlreadyStarted()"
  },
  "api/Cursively.CursivelyTooManyHeadersException.html": {
    "href": "api/Cursively.CursivelyTooManyHeadersException.html",
    "title": "Class CursivelyTooManyHeadersException | Cursively",
    "keywords": "Class CursivelyTooManyHeadersException Raised by CsvReaderVisitorWithUTF8HeadersBase when the number of headers exceeds the configured maximum. Inheritance Object Exception CursivelyDataStreamException CursivelyTooManyHeadersException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : Cursively Assembly : Cursively.dll Syntax [Serializable] public sealed class CursivelyTooManyHeadersException : CursivelyDataStreamException, ISerializable Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Cursively.CursivelyMissingDataFieldsException.html": {
    "href": "api/Cursively.CursivelyMissingDataFieldsException.html",
    "title": "Class CursivelyMissingDataFieldsException | Cursively",
    "keywords": "Class CursivelyMissingDataFieldsException Raised by CsvReaderVisitorWithUTF8HeadersBase , by default, when a data record contains fewer fields than the header record. Inheritance Object Exception CursivelyDataStreamException CursivelyMissingDataFieldsException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : Cursively Assembly : Cursively.dll Syntax [Serializable] public sealed class CursivelyMissingDataFieldsException : CursivelyDataStreamException, ISerializable Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Cursively.CursivelyHeadersAreNotUTF8Exception.html": {
    "href": "api/Cursively.CursivelyHeadersAreNotUTF8Exception.html",
    "title": "Class CursivelyHeadersAreNotUTF8Exception | Cursively",
    "keywords": "Class CursivelyHeadersAreNotUTF8Exception Raised by CsvReaderVisitorWithUTF8HeadersBase , by default, when the header record contains invalid UTF-8 bytes. Inheritance Object Exception CursivelyDataStreamException CursivelyHeadersAreNotUTF8Exception Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : Cursively Assembly : Cursively.dll Syntax [Serializable] public sealed class CursivelyHeadersAreNotUTF8Exception : CursivelyDataStreamException, ISerializable Properties | Improve this Doc View Source InnerDecoderFallbackException Gets the DecoderFallbackException instance that holds the actual decoder state when the current exception was raised. Declaration public DecoderFallbackException InnerDecoderFallbackException { get; } Property Value Type Description DecoderFallbackException Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Cursively.CursivelyHeaderIsTooLongException.html": {
    "href": "api/Cursively.CursivelyHeaderIsTooLongException.html",
    "title": "Class CursivelyHeaderIsTooLongException | Cursively",
    "keywords": "Class CursivelyHeaderIsTooLongException Raised by CsvReaderVisitorWithUTF8HeadersBase when the length of a header exceeds the configured maximum. Inheritance Object Exception CursivelyDataStreamException CursivelyHeaderIsTooLongException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : Cursively Assembly : Cursively.dll Syntax [Serializable] public sealed class CursivelyHeaderIsTooLongException : CursivelyDataStreamException, ISerializable Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Cursively.CursivelyExtraDataFieldsException.html": {
    "href": "api/Cursively.CursivelyExtraDataFieldsException.html",
    "title": "Class CursivelyExtraDataFieldsException | Cursively",
    "keywords": "Class CursivelyExtraDataFieldsException Raised by CsvReaderVisitorWithUTF8HeadersBase , by default, when a data record contains more fields than the header record. Inheritance Object Exception CursivelyDataStreamException CursivelyExtraDataFieldsException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : Cursively Assembly : Cursively.dll Syntax [Serializable] public sealed class CursivelyExtraDataFieldsException : CursivelyDataStreamException, ISerializable Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Cursively.CursivelyDataStreamException.html": {
    "href": "api/Cursively.CursivelyDataStreamException.html",
    "title": "Class CursivelyDataStreamException | Cursively",
    "keywords": "Class CursivelyDataStreamException Serves as the base class for exceptions thrown by this library to indicate problems with the actual contents of a CSV stream. Inheritance Object Exception CursivelyDataStreamException CursivelyExtraDataFieldsException CursivelyHeaderIsTooLongException CursivelyHeadersAreNotUTF8Exception CursivelyMissingDataFieldsException CursivelyTooManyHeadersException Implements ISerializable Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Namespace : Cursively Assembly : Cursively.dll Syntax [Serializable] public abstract class CursivelyDataStreamException : Exception, ISerializable Implements System.Runtime.Serialization.ISerializable"
  },
  "api/Cursively.CsvTokenizer.html": {
    "href": "api/Cursively.CsvTokenizer.html",
    "title": "Class CsvTokenizer | Cursively",
    "keywords": "Class CsvTokenizer Tokenizes a byte stream into CSV fields. The processing follows the guidelines set out in RFC 4180 unless and until the stream proves to be in an incompatible format, in which case a set of additional rules kick in to ensure that all streams are still compatible. The byte stream is tokenized according to the rules of the ASCII encoding. This makes it compatible with any encoding that encodes 0x0A, 0x0D, 0x22, and 0x2C the same way that ASCII encodes them. UTF-8 and Extended ASCII SBCS are notable examples of acceptable encodings. UTF-16 is a notable example of an unacceptable encoding; trying to use this class to process text encoded in an unacceptable encoding will yield undesirable results without any errors. All bytes that appear in the stream except 0x0A, 0x0D, 0x22, and 0x2C are unconditionally treated as data and passed through as-is. It is the consumer's responsibility to handle (or not handle) NUL bytes, invalid UTF-8, leading UTF-8 BOM, or any other quirks that come with the territory of text processing. Inheritance Object CsvTokenizer Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively Assembly : Cursively.dll Syntax public class CsvTokenizer Remarks Each instance of this class expects to process all data from one stream, represented as zero or more ProcessNextChunk(ReadOnlySpan<Byte>, CsvReaderVisitorBase) followed by one ProcessEndOfStream(CsvReaderVisitorBase) , before moving on to another stream. An instance may be reused after a stream has been fully processed, but each instance is also very lightweight, so it is recommended that callers simply create a new instance for each stream that needs to be processed. RFC 4180 leaves a lot of wiggle room for implementers. The following section explains how this implementation resolves ambiguities in the spec, explains where and why we deviate from it, and offers clarifying notes where the spec appears to have \"gotchas\", in the order that the relevant items appear in the spec, primarily modeled off of how Josh Close's CsvHelper library handles the same situations: The spec says that separate lines are delimited by CRLF line breaks. This implementation accepts line breaks of any format (CRLF, LF, CR). The spec says that there may or may not be a line break at the end of the last record in the stream. This implementation does not require there to be a line break, and it would not hurt to add one either. The spec refers to an optional header line at the beginning. This implementation does not include any special treatment for the first line of fields; if they need to be treated as headers, then the consumer needs to know that and respond accordingly. The spec says each record may contain \"one or more fields\". This implementation interprets that to mean strictly that any number of consecutive newline characters in a row are treated as one. Many implementations allow the delimiter character to be configured to be something else other than a comma. This implementation does not currently offer that flexibility. Many implementations allow automatically trimming whitespace at the beginning and/or end of each field (sometimes optionally). The spec expressly advises against doing that, and this implementation follows suit. It is our opinion that consumers ought to be more than capable of trimming spaces at the beginning or end as part of their processing if this is desired. The spec says that the last field in a record must not be followed by a comma. This implementation interprets that to mean that if we do see a comma followed immediately by a line ending character, then that represents the data for an empty field. Finally, the spec has a lot to say about double quotes. This implementation follows the rules that it expressly lays out, but there are some \"gotchas\" that follow from the spec leaving it open-ended how implementations should deal with various streams that include double quotes which do not completely enclose fields, resolved as follows: If a double quote is encountered at the very beginning of a field, then all characters up until the next unescaped double quote or the end of the stream (whichever comes first) are considered to be part of the data for that field (we do translate escaped double quotes for convenience). This includes line ending characters, even though Excel seems to only make that happen if the field counts matching up. If parsing stopped at an unescaped double quote, but there are still more bytes after that double quote before the next delimiter, then all those bytes will be treated verbatim as part of the field's data (double quotes are no longer special at all for the remainder of the field). Double quotes encountered at any other point are included verbatim as part of the field with no special processing. var visitor = new MyVisitorSubclass(); var tokenizer = new CsvTokenizer(); tokenizer.ProcessNextChunk(File.ReadAllBytes(\"...\"), visitor); tokenizer.ProcessEndOfStream(visitor); using (var stream = File.OpenRead(\"...\")) { var visitor = new MyVisitorSubclass(); var tokenizer = new CsvTokenizer(); var buffer = new byte[81920]; int lastRead; while ((lastRead = stream.Read(buffer, 0, buffer.Length)) != 0) { tokenizer.ProcessNextChunk(new ReadOnlySpan<byte>(buffer, 0, lastRead), visitor); } tokenizer.ProcessEndOfStream(visitor); } Constructors | Improve this Doc View Source CsvTokenizer() Initializes a new instance of the CsvTokenizer class. Declaration public CsvTokenizer() | Improve this Doc View Source CsvTokenizer(Byte) Initializes a new instance of the CsvTokenizer class. Declaration public CsvTokenizer(byte delimiter) Parameters Type Name Description Byte delimiter The single byte to expect to see between fields of the same record. This may not be an end-of-line or double-quote character, as those have special meanings. Exceptions Type Condition ArgumentException Thrown when delimiter is 0x0A , 0x0D , or 0x22 . Methods | Improve this Doc View Source IsValidDelimiter(Byte) Checks if a particular byte value is legal for CsvTokenizer(Byte) , i.e., that it is not 0x0A , 0x0D , or 0x22 . Declaration public static bool IsValidDelimiter(byte delimiter) Parameters Type Name Description Byte delimiter The single byte to expect to see between fields of the same record. This may not be an end-of-line or double-quote character, as those have special meanings. Returns Type Description Boolean true if the delimiter is legal for CsvTokenizer(Byte) , false otherwise. | Improve this Doc View Source ProcessEndOfStream(CsvReaderVisitorBase) Informs this tokenizer that the last chunk of data in the stream has been read, and so we should make any final interactions with the CsvReaderVisitorBase and reset our state to prepare for the next stream. Declaration public void ProcessEndOfStream(CsvReaderVisitorBase visitor) Parameters Type Name Description CsvReaderVisitorBase visitor The CsvReaderVisitorBase to interact with, or null if we should simply advance the parser state. Remarks If ProcessNextChunk(ReadOnlySpan<Byte>, CsvReaderVisitorBase) has never been called (or has not been called since the last time that this method was called), then this method will do nothing. | Improve this Doc View Source ProcessNextChunk(ReadOnlySpan<Byte>, CsvReaderVisitorBase) Accepts the next (or first) chunk of data in the CSV stream, and informs an instance of CsvReaderVisitorBase what it contains. Declaration public void ProcessNextChunk(ReadOnlySpan<byte> chunk, CsvReaderVisitorBase visitor) Parameters Type Name Description ReadOnlySpan < Byte > chunk A ReadOnlySpan<T> containing the next chunk of data. CsvReaderVisitorBase visitor The CsvReaderVisitorBase to interact with, or null if we should simply advance the parser state. Remarks If chunk is empty, this method will do nothing."
  },
  "api/Cursively.CsvSyncInput.html": {
    "href": "api/Cursively.CsvSyncInput.html",
    "title": "Class CsvSyncInput | Cursively",
    "keywords": "Class CsvSyncInput Helpers to create inputs that describe CSV data streams synchronously. Inheritance Object CsvSyncInput Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively Assembly : Cursively.dll Syntax public static class CsvSyncInput Methods | Improve this Doc View Source ForMemory(ReadOnlyMemory<Byte>) Creates an input that can describe the contents of a given ReadOnlyMemory<T> of bytes to an instance of CsvReaderVisitorBase , synchronously. Declaration public static CsvReadOnlyMemoryInput ForMemory(ReadOnlyMemory<byte> memory) Parameters Type Name Description ReadOnlyMemory < Byte > memory The ReadOnlyMemory<T> of bytes that contains the CSV data. Returns Type Description CsvReadOnlyMemoryInput An instance of CsvReadOnlyMemoryInput wrapping memory . | Improve this Doc View Source ForMemoryMappedFile(String) Creates an input that can describe the contents of a given file to an instance of CsvReaderVisitorBase , synchronously using memory-mapping. Declaration public static CsvMemoryMappedFileInput ForMemoryMappedFile(string csvFilePath) Parameters Type Name Description String csvFilePath The path to the file that contains the CSV data. The only validation that Cursively does is IsNullOrWhiteSpace(String) . Returns Type Description CsvMemoryMappedFileInput An instance of CsvMemoryMappedFileInput wrapping csvFilePath . Exceptions Type Condition ArgumentNullException Thrown when csvFilePath is null . ArgumentException Thrown when csvFilePath is non- null , but is either empty or whitespace-only. | Improve this Doc View Source ForSequence(ReadOnlySequence<Byte>) Creates an input that can describe the contents of a given ReadOnlySequence<T> of bytes to an instance of CsvReaderVisitorBase , synchronously. Declaration public static CsvReadOnlySequenceInput ForSequence(ReadOnlySequence<byte> sequence) Parameters Type Name Description ReadOnlySequence < Byte > sequence The ReadOnlySequence<T> of bytes that contains the CSV data. Returns Type Description CsvReadOnlySequenceInput An instance of CsvReadOnlySequenceInput wrapping sequence . | Improve this Doc View Source ForStream(Stream) Creates an input that can describe the contents of a given Stream to an instance of CsvReaderVisitorBase , synchronously. Declaration public static CsvSyncStreamInput ForStream(Stream csvStream) Parameters Type Name Description Stream csvStream The Stream that contains the CSV data. Returns Type Description CsvSyncStreamInput An instance of CsvSyncStreamInput wrapping csvStream . Exceptions Type Condition ArgumentException Thrown when csvStream is non- null and its CanRead is false ."
  },
  "api/Cursively.CsvReaderVisitorWithUTF8HeadersBase.html": {
    "href": "api/Cursively.CsvReaderVisitorWithUTF8HeadersBase.html",
    "title": "Class CsvReaderVisitorWithUTF8HeadersBase | Cursively",
    "keywords": "Class CsvReaderVisitorWithUTF8HeadersBase Intermediate base class for CSV reader visitors that don't want to have to implement header handling by themselves. Instances of this class are tied to a single CSV stream and cannot be reused or reset for use with other CSV streams. Each instance of this visitor has an upper-bound on the maximum number of headers and on the maximum length of each header. CSV streams that exceed these limits will cause this class to throw exceptions, and behavior of a particular instance is undefined once this happens. Inheritance Object CsvReaderVisitorBase CsvReaderVisitorWithUTF8HeadersBase Inherited Members CsvReaderVisitorBase.Null CsvReaderVisitorBase.VisitNonstandardQuotedField() Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively Assembly : Cursively.dll Syntax public abstract class CsvReaderVisitorWithUTF8HeadersBase : CsvReaderVisitorBase Remarks The following input-dependent exceptions may get thrown when using this visitor, all of which inherit from CursivelyDataStreamException : CursivelyHeadersAreNotUTF8Exception if DefaultDecoderFallback is being used and the CSV stream contains a sequence of invalid UTF-8 bytes. CursivelyHeaderIsTooLongException if the CSV stream contains one or more headers that are longer than the configured maximum. CursivelyTooManyHeadersException if the CSV stream contains more headers than the configured maximum. CursivelyMissingDataFieldsException , by default, if a data record contains more fields than the header record. CursivelyExtraDataFieldsException , by default, if a data record contains more fields than the header record. Constructors | Improve this Doc View Source CsvReaderVisitorWithUTF8HeadersBase() Initializes a new instance of the CsvReaderVisitorWithUTF8HeadersBase class. Declaration [Obsolete(\"Use the parameterized constructor, passing in 'false' for the flag to ignore a UTF-8 identifier on the first header field; instead, remove UTF-8 identifiers on the input itself. See airbreather/Cursively#14.\")] protected CsvReaderVisitorWithUTF8HeadersBase() | Improve this Doc View Source CsvReaderVisitorWithUTF8HeadersBase(Int32, Int32, Boolean, DecoderFallback) Initializes a new instance of the CsvReaderVisitorWithUTF8HeadersBase class. Declaration protected CsvReaderVisitorWithUTF8HeadersBase(int maxHeaderCount, int maxHeaderLength, bool ignoreUTF8IdentifierOnFirstHeaderField, DecoderFallback decoderFallback) Parameters Type Name Description Int32 maxHeaderCount The maximum number of headers to allow. Default: DefaultMaxHeaderCount . Int32 maxHeaderLength The maximum length, in UTF-16 code units, of any particular header. Default: DefaultMaxHeaderLength . Boolean ignoreUTF8IdentifierOnFirstHeaderField A value indicating whether or not to ignore a leading UTF-8 BOM. Default: DefaultIgnoreUTF8IdentifierOnFirstHeaderField . This parameter was a mistake (see airbreather/Cursively#14) and will be removed in 2.x. Instead, always pass in false , and remove UTF-8 identifiers directly at the source instead of leaving it up to the visitor. DecoderFallback decoderFallback The fallback logic used when the decoder encounters invalid UTF-8 bytes. Default: DefaultDecoderFallback . Exceptions Type Condition ArgumentNullException Thrown when decoderFallback is null . ArgumentOutOfRangeException Thrown when maxHeaderCount or maxHeaderLength is less than 1 or greater than the maximum for that parameter ( MaxMaxHeaderCount / MaxMaxHeaderLength ). Fields | Improve this Doc View Source DefaultDecoderFallback The value used by CsvReaderVisitorWithUTF8HeadersBase() to initialize the fallback logic when the decoder encounters invalid UTF-8 bytes (throw an exception). Declaration protected static readonly DecoderFallback DefaultDecoderFallback Field Value Type Description DecoderFallback | Improve this Doc View Source DefaultIgnoreUTF8IdentifierOnFirstHeaderField The value used by CsvReaderVisitorWithUTF8HeadersBase() to initialize the value indicating whether or not to ignore a leading UTF-8 BOM (true). Declaration [Obsolete(\"Always pass in 'false' instead, per airbreather/Cursively#14\")] protected static readonly bool DefaultIgnoreUTF8IdentifierOnFirstHeaderField Field Value Type Description Boolean | Improve this Doc View Source DefaultMaxHeaderCount The value used by CsvReaderVisitorWithUTF8HeadersBase() to initialize the maximum number of headers (1,000). Declaration protected static readonly int DefaultMaxHeaderCount Field Value Type Description Int32 | Improve this Doc View Source DefaultMaxHeaderLength The value used by CsvReaderVisitorWithUTF8HeadersBase() to initialize the maximum length, in UTF-16 code units, of a single header (100). Declaration protected static readonly int DefaultMaxHeaderLength Field Value Type Description Int32 | Improve this Doc View Source MaxMaxHeaderCount The maximum value that's legal for the maximum header count (0x7FEFFFFF). Staying within this limit does not guarantee that you will be immune to OutOfMemoryException even with enough system virtual memory (that depends on your configuration). This is just the threshold that, if exceeded, guarantees that you actually *will* see OutOfMemoryException on mainstream frameworks if Cursively actually tried to go that high, so this is used as a \"fail-fast\". Declaration protected static readonly int MaxMaxHeaderCount Field Value Type Description Int32 | Improve this Doc View Source MaxMaxHeaderLength The maximum value that's legal for the maximum header length (0x7FEFFFFF). Staying within this limit does not guarantee that you will be immune to OutOfMemoryException even with enough system virtual memory (that depends on your configuration). This is just the threshold that, if exceeded, guarantees that you actually *will* see OutOfMemoryException on mainstream frameworks if Cursively actually tried to go that high, so this is used as a \"fail-fast\". Declaration protected static readonly int MaxMaxHeaderLength Field Value Type Description Int32 Properties | Improve this Doc View Source CurrentFieldIndex Gets the zero-based index of the field that is currently being read. The value should be the length of Headers during VisitEndOfHeaderRecord() and VisitEndOfDataRecord() , except after VisitMissingDataFields() or VisitUnexpectedDataField() has been called. Declaration protected int CurrentFieldIndex { get; } Property Value Type Description Int32 | Improve this Doc View Source Headers Gets the headers of the CSV stream. Only valid after VisitEndOfHeaderRecord() has been called. Declaration protected ImmutableArray<string> Headers { get; } Property Value Type Description ImmutableArray < String > Remarks Once initialized, the value will remain the same for as long as this object instance stays alive. Exceptions Type Condition InvalidOperationException Thrown when trying to access this value before VisitEndOfHeaderRecord() has been called. Methods | Improve this Doc View Source VisitEndOfDataField(ReadOnlySpan<Byte>) Visits the last part of a non-header field's data. Declaration protected abstract void VisitEndOfDataField(ReadOnlySpan<byte> chunk) Parameters Type Name Description ReadOnlySpan < Byte > chunk The data from the last part of the field. Remarks See documentation for VisitEndOfField(ReadOnlySpan<Byte>) for details about when and how this method will be called. | Improve this Doc View Source VisitEndOfDataRecord() Notifies that all fields in the current non-header record have been visited. Declaration protected abstract void VisitEndOfDataRecord() Remarks See documentation for VisitEndOfRecord() for details about when and how this method will be called. | Improve this Doc View Source VisitEndOfField(ReadOnlySpan<Byte>) Visits the last part of a field's data. Declaration public override sealed void VisitEndOfField(ReadOnlySpan<byte> chunk) Parameters Type Name Description ReadOnlySpan < Byte > chunk The data from the last part of the field. Overrides CsvReaderVisitorBase.VisitEndOfField(ReadOnlySpan<Byte>) Remarks This method may be called at any time. Any method except VisitNonstandardQuotedField() , including this one, may be called directly after a call to this method. This method may be called without a preceding VisitPartialFieldContents(ReadOnlySpan<Byte>) call, if the field's entire data is contained within the given chunk. | Improve this Doc View Source VisitEndOfHeaderRecord() Notifies that all headers have been read and Headers is safe to read. The default behavior is to do nothing. Declaration protected virtual void VisitEndOfHeaderRecord() | Improve this Doc View Source VisitEndOfRecord() Notifies that all fields in the current record have been visited. Declaration public override sealed void VisitEndOfRecord() Overrides CsvReaderVisitorBase.VisitEndOfRecord() Remarks This method may only be called as the very next method that gets called after a call to VisitEndOfField(ReadOnlySpan<Byte>) . Only VisitPartialFieldContents(ReadOnlySpan<Byte>) and VisitEndOfField(ReadOnlySpan<Byte>) may be called directly after a call to this method. | Improve this Doc View Source VisitMissingDataFields() Notifies that the current non-header record is about to be terminated without reading all the fields that were identified in the header record. The default behavior is to throw CursivelyMissingDataFieldsException . Declaration protected virtual void VisitMissingDataFields() | Improve this Doc View Source VisitPartialDataFieldContents(ReadOnlySpan<Byte>) Visits part of a non-header field's data. Declaration protected abstract void VisitPartialDataFieldContents(ReadOnlySpan<byte> chunk) Parameters Type Name Description ReadOnlySpan < Byte > chunk The data from this part of the field. Remarks See documentation for VisitPartialFieldContents(ReadOnlySpan<Byte>) for details about when and how this method will be called. | Improve this Doc View Source VisitPartialFieldContents(ReadOnlySpan<Byte>) Visits part of a field's data. Declaration public override sealed void VisitPartialFieldContents(ReadOnlySpan<byte> chunk) Parameters Type Name Description ReadOnlySpan < Byte > chunk The data from this part of the field. Overrides CsvReaderVisitorBase.VisitPartialFieldContents(ReadOnlySpan<Byte>) Remarks This method may be called at any time. Only VisitPartialFieldContents(ReadOnlySpan<Byte>) , VisitEndOfField(ReadOnlySpan<Byte>) , and VisitNonstandardQuotedField() may be called directly after a call to this method. There are multiple reasons why this method may be called instead of going straight to calling VisitEndOfField(ReadOnlySpan<Byte>) : Field is split across multiple read buffer chunks, or else it runs up to the very end of a read buffer chunk, but we can't prove it without the first byte of the next chunk or a ProcessEndOfStream(CsvReaderVisitorBase) call. Quoted field contains a literal quote that was escaped in the original stream, and so we cannot yield the entire field data as-is. Stream does not conform to RFC 4180, and optimizing such streams to avoid this case. | Improve this Doc View Source VisitUnexpectedDataField() Notifies that data for a field is about to be read on a non-header record, but all the fields that were identified in the header record have already been read. This method is called before every single VisitPartialDataFieldContents(ReadOnlySpan<Byte>) or VisitEndOfDataField(ReadOnlySpan<Byte>) call for fields not present in the header record. The default behavior is to throw CursivelyExtraDataFieldsException . Declaration protected virtual void VisitUnexpectedDataField()"
  },
  "api/Cursively.CsvReaderVisitorBase.html": {
    "href": "api/Cursively.CsvReaderVisitorBase.html",
    "title": "Class CsvReaderVisitorBase | Cursively",
    "keywords": "Class CsvReaderVisitorBase Base class for listeners that process a stream of RFC 4180 (CSV) tokens from an instance of CsvTokenizer . Inheritance Object CsvReaderVisitorBase CsvReaderVisitorWithUTF8HeadersBase Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively Assembly : Cursively.dll Syntax public abstract class CsvReaderVisitorBase Remarks Remarks on the documentation of individual abstract methods indicate when the tokenizer is legally allowed to call that method. Fields | Improve this Doc View Source Null An implementation of CsvReaderVisitorBase that does nothing when it sees any of the tokens. Declaration public static readonly CsvReaderVisitorBase Null Field Value Type Description CsvReaderVisitorBase Methods | Improve this Doc View Source VisitEndOfField(ReadOnlySpan<Byte>) Visits the last part of a field's data. Declaration public abstract void VisitEndOfField(ReadOnlySpan<byte> chunk) Parameters Type Name Description ReadOnlySpan < Byte > chunk The data from the last part of the field. Remarks This method may be called at any time. Any method except VisitNonstandardQuotedField() , including this one, may be called directly after a call to this method. This method may be called without a preceding VisitPartialFieldContents(ReadOnlySpan<Byte>) call, if the field's entire data is contained within the given chunk. | Improve this Doc View Source VisitEndOfRecord() Notifies that all fields in the current record have been visited. Declaration public abstract void VisitEndOfRecord() Remarks This method may only be called as the very next method that gets called after a call to VisitEndOfField(ReadOnlySpan<Byte>) . Only VisitPartialFieldContents(ReadOnlySpan<Byte>) and VisitEndOfField(ReadOnlySpan<Byte>) may be called directly after a call to this method. | Improve this Doc View Source VisitNonstandardQuotedField() Notifies that the current field contains double-quote characters that do not comply with RFC 4180, and so it is being processed according to this library's extra rules. The default behavior of this method is to do nothing. Subclasses may wish to override to add warnings / errors when processing streams that do not follow RFC 4180 and are therefore in danger of being processed differently than other tools. Declaration public virtual void VisitNonstandardQuotedField() Remarks This method may only be called as the very next method that gets called after a call to VisitPartialFieldContents(ReadOnlySpan<Byte>) , and only at most once per field (i.e., once it is called, it may not be called again until a VisitEndOfField(ReadOnlySpan<Byte>) call brings the tokenizer back to a state where RFC 4180 rules are expected). Only VisitPartialFieldContents(ReadOnlySpan<Byte>) and VisitEndOfField(ReadOnlySpan<Byte>) may be called directly after a call to this method. The last byte in the preceding VisitPartialFieldContents(ReadOnlySpan<Byte>) call's chunk will be the specific byte that was unexpected; all bytes before it were legal under RFC 4180. So if this event is being raised because the tokenizer found a double-quote in a field that did not start with a double-quote, then VisitPartialFieldContents(ReadOnlySpan<Byte>) was previously called with a chunk that ended with that double-quote. If it's being raised because a double-quote was found in a quoted field that was not immediately followed by a double-quote, delimiter, or line ending, then VisitPartialFieldContents(ReadOnlySpan<Byte>) was previously called with a chunk that ended with whichever byte immediately followed the double-quote that ended the quoted part of the quoted field data. | Improve this Doc View Source VisitPartialFieldContents(ReadOnlySpan<Byte>) Visits part of a field's data. Declaration public abstract void VisitPartialFieldContents(ReadOnlySpan<byte> chunk) Parameters Type Name Description ReadOnlySpan < Byte > chunk The data from this part of the field. Remarks This method may be called at any time. Only VisitPartialFieldContents(ReadOnlySpan<Byte>) , VisitEndOfField(ReadOnlySpan<Byte>) , and VisitNonstandardQuotedField() may be called directly after a call to this method. There are multiple reasons why this method may be called instead of going straight to calling VisitEndOfField(ReadOnlySpan<Byte>) : Field is split across multiple read buffer chunks, or else it runs up to the very end of a read buffer chunk, but we can't prove it without the first byte of the next chunk or a ProcessEndOfStream(CsvReaderVisitorBase) call. Quoted field contains a literal quote that was escaped in the original stream, and so we cannot yield the entire field data as-is. Stream does not conform to RFC 4180, and optimizing such streams to avoid this case."
  },
  "api/Cursively.CsvAsyncInput.html": {
    "href": "api/Cursively.CsvAsyncInput.html",
    "title": "Class CsvAsyncInput | Cursively",
    "keywords": "Class CsvAsyncInput Helpers to create inputs that describe CSV data streams asynchronously. Inheritance Object CsvAsyncInput Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively Assembly : Cursively.dll Syntax public static class CsvAsyncInput Methods | Improve this Doc View Source ForPipeReader(PipeReader) Creates an input that can describe the contents of a given PipeReader to an instance of CsvReaderVisitorBase , asynchronously. Declaration public static CsvPipeReaderInput ForPipeReader(PipeReader reader) Parameters Type Name Description PipeReader reader The PipeReader that contains the CSV data. Returns Type Description CsvPipeReaderInput An instance of CsvPipeReaderInput wrapping reader . | Improve this Doc View Source ForStream(Stream) Creates an input that can describe the contents of a given Stream to an instance of CsvReaderVisitorBase , asynchronously. Declaration public static CsvAsyncStreamInput ForStream(Stream csvStream) Parameters Type Name Description Stream csvStream The Stream that contains the CSV data. Returns Type Description CsvAsyncStreamInput An instance of CsvAsyncStreamInput wrapping csvStream . Exceptions Type Condition ArgumentException Thrown when csvStream is non- null and its CanRead is false ."
  },
  "api/Cursively.Csv.html": {
    "href": "api/Cursively.Csv.html",
    "title": "Class Csv | Cursively",
    "keywords": "Class Csv Contains helper methods for CSV processing. Inheritance Object Csv Inherited Members Object.Equals(Object) Object.Equals(Object, Object) Object.GetHashCode() Object.GetType() Object.MemberwiseClone() Object.ReferenceEquals(Object, Object) Object.ToString() Namespace : Cursively Assembly : Cursively.dll Syntax [Obsolete(\"ProcessFoo methods have been moved to instance methods on dedicated 'input' types for better composability.\")] public static class Csv Methods | Improve this Doc View Source ProcessFile(String, CsvReaderVisitorBase) Describes the entire contents of a CSV file to the given instance of the CsvReaderVisitorBase class. Declaration [Obsolete(\"Use CsvSyncInput.ForMemoryMappedFile(csvFilePath).Process(visitor).\")] public static void ProcessFile(string csvFilePath, CsvReaderVisitorBase visitor) Parameters Type Name Description String csvFilePath The path to the CSV file to describe. CsvReaderVisitorBase visitor The CsvReaderVisitorBase instance to describe the file to. Remarks The current version of this method uses memory-mapping behind the scenes in order to minimize the overhead of copying and cutting across discrete buffers, at the expense of slightly more overhead to set up the memory map than a typical read-from-stream pattern. Exceptions Type Condition ArgumentNullException See FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions) . ArgumentException See FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions) . NotSupportedException See FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions) . FileNotFoundException See FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions) . IOException See FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions) . See CreateViewAccessor(Int64, Int64, MemoryMappedFileAccess) . SecurityException See FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions) . DirectoryNotFoundException See FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions) . UnauthorizedAccessException See FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions) . PathTooLongException See FileStream(String, FileMode, FileAccess, FileShare, Int32, FileOptions) . | Improve this Doc View Source ProcessStream(Stream, CsvReaderVisitorBase) Describes the contents of a CSV stream to the given instance of the CsvReaderVisitorBase class. Declaration [Obsolete(\"Use CsvSyncInput.ForStream(csvStream).Process(visitor).\")] public static void ProcessStream(Stream csvStream, CsvReaderVisitorBase visitor) Parameters Type Name Description Stream csvStream The CSV stream to describe. CsvReaderVisitorBase visitor The CsvReaderVisitorBase instance to describe the stream to. Exceptions Type Condition ArgumentNullException Thrown when csvStream is null . | Improve this Doc View Source ProcessStream(Stream, CsvReaderVisitorBase, Int32) Describes the contents of a CSV stream to the given instance of the CsvReaderVisitorBase class. Declaration [Obsolete(\"Use CsvSyncInput.ForStream(csvStream).WithMinReadBufferByteCount(bufferSize).Process(visitor).\")] public static void ProcessStream(Stream csvStream, CsvReaderVisitorBase visitor, int bufferSize) Parameters Type Name Description Stream csvStream The CSV stream to describe. CsvReaderVisitorBase visitor The CsvReaderVisitorBase instance to describe the stream to. Int32 bufferSize The length of the buffer to use (default: 81920). Exceptions Type Condition ArgumentNullException Thrown when csvStream is null . ArgumentOutOfRangeException Thrown when bufferSize is not greater than zero. ArgumentException Thrown when csvStream does not support reading (i.e., CanRead is false ). | Improve this Doc View Source ProcessStreamAsync(Stream, CsvReaderVisitorBase, Int32, IProgress<Int32>, CancellationToken) Describes the contents of a CSV stream to the given instance of the CsvReaderVisitorBase class. Declaration [Obsolete(\"Use CsvAsyncInput.ForStream(csvStream).WithMinReadBufferByteCount(bufferSize).ProcessAsync(visitor, progress, cancellationToken).\")] public static ValueTask ProcessStreamAsync(Stream csvStream, CsvReaderVisitorBase visitor, int bufferSize, IProgress<int> progress = null, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description Stream csvStream The CSV stream to describe. CsvReaderVisitorBase visitor The CsvReaderVisitorBase instance to describe the stream to. Int32 bufferSize The length of the buffer to use (default: 81920). IProgress < Int32 > progress An IProgress<T> that will be notified every time the next chunk of the stream is processed, with the size of the chunk (in bytes) that was processed. All notifications will receive values less than or equal to the buffer size in bytes (which, for this overload, is the value of bufferSize ). There will be one last notification with value 0 after the entire stream has been processed and the final few stream elements have been consumed. This may be left as null if no progress notifications are needed. CancellationToken cancellationToken An instance of CancellationToken that may be used to signal that results are no longer needed, and so the method should terminate at its earliest convenience. This may be left as its default value of None if the operation does not need to support cancellation. Returns Type Description ValueTask Exceptions Type Condition ArgumentNullException Thrown when csvStream is null . ArgumentOutOfRangeException Thrown when bufferSize is not greater than zero. ArgumentException Thrown when csvStream does not support reading (i.e., CanRead is false ). OperationCanceledException Thrown (perhaps asynchronously) to acknowledge cancellation. A derived exception, such as TaskCanceledException , may also be thrown by the system. ObjectDisposedException Thrown (perhaps asynchronously) if the underlying CancellationTokenSource object backing cancellationToken is disposed before the asynchronous operation terminates. | Improve this Doc View Source ProcessStreamAsync(Stream, CsvReaderVisitorBase, IProgress<Int32>, CancellationToken) Describes the contents of a CSV stream to the given instance of the CsvReaderVisitorBase class. Declaration [Obsolete(\"Use CsvAsyncInput.ForStream(csvStream).ProcessAsync(visitor, progress, cancellationToken).\")] public static ValueTask ProcessStreamAsync(Stream csvStream, CsvReaderVisitorBase visitor, IProgress<int> progress = null, CancellationToken cancellationToken = default(CancellationToken)) Parameters Type Name Description Stream csvStream The CSV stream to describe. CsvReaderVisitorBase visitor The CsvReaderVisitorBase instance to describe the stream to. IProgress < Int32 > progress An IProgress<T> that will be notified every time the next chunk of the stream is processed, with the size of the chunk (in bytes) that was processed. All notifications will receive values less than or equal to the buffer size in bytes (which, for this overload, is the default value of 81,920). There will be one last notification with value 0 after the entire stream has been processed and the final few stream elements have been consumed. This may be left as null if no progress notifications are needed. CancellationToken cancellationToken An instance of CancellationToken that may be used to signal that results are no longer needed, and so the method should terminate at its earliest convenience. This may be left as its default value of None if the operation does not need to support cancellation. Returns Type Description ValueTask Exceptions Type Condition ArgumentNullException Thrown when csvStream is null . ArgumentException Thrown when csvStream does not support reading (i.e., CanRead is false ). OperationCanceledException Thrown (perhaps asynchronously) to acknowledge cancellation. A derived exception, such as TaskCanceledException , may also be thrown by the system. ObjectDisposedException Thrown (perhaps asynchronously) if the underlying CancellationTokenSource object backing cancellationToken is disposed before the asynchronous operation terminates."
  }
}